{"pages":[],"posts":[{"title":"ArcGIS API for JavaScript 安装和配置","text":"ArcGIS API for JavaScript是将地理信息或者地理数据进行可视化表达或者地理分析处理的JS库，可用于浏览器环境和Node.js环境^1。要在项目中使用ArcGIS JS API，有下面几种方式。 AMD与ESM选择API安装方式的前置条件，只做简单介绍。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 1require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。 ES Module把一个文件当作一个模块，每个模块有自己的独立作用域，核心点就是模块的导入（import）与导出（export）。 export后只能跟function、class、var、let、const、default、{}，export的作用就是给当前模块对象添加属性，方便后期导入到其他模块中，其中 export default方法最常用。 import命令用于导入其他模块提供的数据，格式： 1import &lt;module&gt; from &lt;url&gt; API安装的四种方式 CDN (AMD) ESM local build AMD local build 不需要安装，配置和本地构建 X 通过CDN缓存快速下载 X 可以通过npm快速安装 X 与大多数现代框架和构建工具无缝集成 X 使用4.17版本或更早的API与框架或构建工具 X 使用 Dojo 1 或者 RequireJS X 通过CDN提供的AMD模块访问API的最常见方法是使用托管版本。 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/4.20/esri/themes/light/main.css&quot;&gt;&lt;script src=&quot;https://js.arcgis.com/4.20/&quot;&gt;&lt;/script&gt; 通过NPM提供的ES模块^1API也可以通过npm作为ES模块使用。你可以在本地安装API，以便与React和Vue等JavaScript框架以及webpack等打包器一起使用。 安装 1yarn add @arcgis/core 配置CSS 复制/node_modules/@arcgis/core/assets到/public/assets文件夹中 配置ArcGIS资源路径为本地路径 12import esriConfig from &quot;@arcgis/core/config.js&quot;;esriConfig.assetsPath = &quot;./assets&quot;; 全局CSS文件中引入ArcGIS本地样式文件 1@import &quot;~@arcgis/core/assets/esri/themes/light/main.css&quot;; 导入 1import Map from &quot;@arcgis/core/Map&quot;; 在本地托管的AMD模块修改API中init.js文件和dojo.js文件，将修改好的API部署在自有服务器中，用于网络缺失及网络较差的环境中。 较早版本 下载 ArcGIS JS API 下载网站 下载分为API和SDK，API包含开发所需的库文件，SDK为离线文档和实例^2。 将压缩包解压，复制\\arcgis_js_v420_api\\arcgis_js_api\\javascript\\4.20\\ 及下面所有内容到托管服务器目录中。例如C:\\Inetpub\\wwwroot\\javascript\\api\\4.20\\。 打开 C:\\Inetpub\\wwwroot\\javascript\\api\\4.20\\init.js 搜索 [HOSTNAME_AND_PATH_TO_JSAPI], 并替换为以下字符串 www.example.com/javascript/api/4.20/init.js。 较新版本 下载同上 将压缩包解压，复制\\javascript\\4.22\\ 及下面所有内容到托管服务器目录中。例如C:\\Inetpub\\wwwroot\\javascript\\4.22\\。 通过浏览器访问安装根目录中的index.html文件，如http://localhost/javascript/4.22/，根据输出信息判断是否安装成功。 通过CDN提供的ES模块^1==注意：这种方法目前只推荐用于开发和原型阶段。== 123456&lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/4.20/@arcgis/core/assets/esri/themes/light/main.css&quot;&gt;&lt;script type=&quot;module&quot;&gt; import Map from &quot;https://js.arcgis.com/4.20/@arcgis/core/Map.js&quot;; // Use the Map class&lt;/script&gt; 服务器配置托管 ArcGIS API for JavaScript 的 Web 服务器将需要注册以下 MIME/type（主要为IIS）。 extension MIME/type Description .ttf application/octet-stream True Type Fonts .wasm application/wasm WebAssembly .woff application/font-woff Web Open Font Format .woff2 application/font-woff2 WOFF File Format 2.0 .wsv application/octet-stream Supports SceneView‘s stars visualization","link":"/2022/03/30/ArcGIS-API-for-JavaScript-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"title":"ArcGIS API for JavaScript 使用方法说明","text":"构造函数ArcGIS API for JavaScript中的所有类都有一个构造函数，所有属性都可以通过向构造函数传递参数来设置。 12345678910const map = new Map({ basemap: &quot;topo-vector&quot;});const view = new MapView({ map: map, container: &quot;map-div&quot;, center: [ -122, 38 ], scale: 5}); 另外，对象的属性可以直接使用setters来指定。 12345678910111213const map = new Map();const view = new MapView();map.basemap = &quot;topo-vector&quot;; // Set a propertyconst viewProps = { // Object with property data container: &quot;map-div&quot;, map: map, scale: 5000, center: [ -122, 38 ]};view.set(viewProps); // Use a setter 属性Gettersget方法返回一个属性的值，这个方法是一个快捷方法，因为如果不使用get()，要返回嵌套属性的值，例如，要返回一个Map对象的属性basemap的标题，需要一个if语句来检查basemap是否未定义或为空。 1234const basemapTitle = null;if (map.basemap) { // Make sure `map.basemap` exists basemapTitle = map.basemap.title;} get 方法不需要 if 语句，如果 map.basemap 存在，则返回 map.basemap.title 的值，否则返回 null。 1const basemapTitle = map.get(&quot;basemap.title&quot;); ==注意：== 也可以采用可选链(?.)操作规避这类问题，但是需要考虑浏览器兼容性。 1const basemapTitle = map?.basemap.title; Setters可以直接设置属性的值。 123view.center = [ -100, 40 ];view.zoom = 6;map.basemap = &quot;oceans&quot;; 当需要更改多个属性值时， set() 可以传递一个带有属性名和新值的 JavaScript 对象。 123456const newViewProperties = { center: [ -100, 40 ], zoom: 6};view.set(newViewProperties); 监听属性变化使用 watch() 来监听属性的变化，它带有两个参数：作为字符串的属性名称，以及当属性值更改时调用的回调函数。watch()返回一个WatchHandle实例。代码示例监听一个Map对象的basemap.title属性，每当底图标题发生改变时，就调用titleChangeCallback函数。 123456789101112const map = new Map({ basemap: &quot;streets-vector&quot;});function titleChangeCallback (newValue, oldValue, property, object) { console.log(&quot;New value: &quot;, newValue, &quot;&lt;br&gt;Old value: &quot;, oldValue, &quot;&lt;br&gt;Watched property: &quot;, property, &quot;&lt;br&gt;Watched object: &quot;, object);};const handle = map.watch('basemap.title', titleChangeCallback); 可以在 WatchHandle 对象上调用 remove 方法来停止监听。 1handle.remove(); ==注意：== 并非所有的属性都可以被监听，例如集合。注册一个事件处理程序，以便在一个集合发生changes时可以被监听。 因为FeatureLayer.source和GraphicsLayer.graphics属性都是集合，使用on()而不是watch()来监听这些属性的变化。 AutocastingAutocasting将JavaScript对象作为ArcGIS API for JavaScript 类类型，而不需要开发人员显式导入这些类。 ==注意：== 目前，由于TypeScript的限制，Autocasting在非TypeScript应用程序中效果最好。 代码示例中，需要五个API类来为一个FeatureLayer创建一个SimpleRenderer。 1234567891011121314151617181920212223require([ &quot;esri/Color&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/renderers/SimpleRenderer&quot;, &quot;esri/layers/FeatureLayer&quot;,], ( Color, SimpleLineSymbol, SimpleMarkerSymbol, SimpleRenderer, FeatureLayer) =&gt; { const layer = new FeatureLayer({ url: &quot;https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/WorldCities/FeatureServer/0&quot;, renderer: new SimpleRenderer({ symbol: new SimpleMarkerSymbol({ style: &quot;diamond&quot;, color: new Color([255, 128, 45]), outline: new SimpleLineSymbol({ style: &quot;dash-dot&quot;, color: new Color([0, 0, 0]) }) }) }) });}); 通过Autocasting，不必导入渲染器和符号类；唯一需要导入的模块是esri/layers/FeatureLayer。 12345678910111213141516require([ &quot;esri/layers/FeatureLayer&quot; ], (FeatureLayer) =&gt; { const layer = new FeatureLayer({ url: &quot;https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/WorldCities/FeatureServer/0&quot;, renderer: { // autocasts as new SimpleRenderer() symbol: { // autocasts as new SimpleMarkerSymbol() type: &quot;simple-marker&quot;, style: &quot;diamond&quot;, color: [ 255, 128, 45 ], // autocasts as new Color() outline: { // autocasts as new SimpleLineSymbol() style: &quot;dash-dot&quot;, color: [ 0, 0, 0 ] // autocasts as new Color() } } } });}); 想知道一个类是否可以Autocasting，查看每个类的文档。如果一个属性可以被Autocasting，就会出现以下图片： 异步数据PromisePromise通常与then()一起使用，它定义了回调函数，如果resolved，则调用该函数，如果rejected，则调用错误函数。第一个参数始终是成功回调，第二个可选参数是错误回调。 1someAsyncFunction().then(callback, errorCallback); catch()方法可以用来指定一个Promise或Promise函数链的错误回调函数。 123456someAsyncFunction() .then((resolvedVal) =&gt; { console.log(resolvedVal); }).catch((error) =&gt; { console.error(error); }); 示例中，GeometryService被用来将几个点的几何图形投射到一个新的空间参考。在GeometryService.project的文档中，project()返回一个Promise，该Promise解析为一个投影的几何体数组。 1234567891011121314151617require([ &quot;esri/tasks/GeometryService&quot;, &quot;esri/tasks/support/ProjectParameters&quot;, ], (GeometryService, ProjectParameters) =&gt; { const geoService = new GeometryService( &quot;https://sampleserver6.arcgisonline.com/arcgis/rest/services/Utilities/Geometry/GeometryServer&quot; ); const projectParams = new ProjectParameters({ geometries: [points], outSR: outSR, transformation = transformation }); geoService.project(projectParams) .then((projectedGeoms) =&gt; { console.log(&quot;projected points: &quot;, projectedGeoms); }, (error) =&gt; { console.error(error); });}); Promise 函数链使用Promise 的优点之一是可以利用then()将多个Promise 连接起来。当一个以上的Promise 被链在一起时，一个Promise 的解析值将被被传递给下一个Promise 。这使得代码块可以按顺序执行，而不需要在彼此之间嵌套回调。 ==注意：== 回调函数必须使用return关键字来返回一个值给下一个Promise 。 123456789101112131415161718192021222324252627282930313233343536const bufferLayer = new GraphicsLayer();function bufferPoints(points) { return geometryEngine.geodesicBuffer(points, 1000, &quot;feet&quot;);}function addGraphicsToBufferLayer(buffers) { buffers.forEach((buffer) =&gt; { bufferLayer.add(new Graphic(buffer)); }); return buffers;}function calculateArea(buffer) { return geometryEngine.geodesicArea(buffer, &quot;square-feet&quot;);}function calculateAreas(buffers) { return buffers.map(calculateArea);}function sumArea(areas) { for (let i = 0, total = 0; i &lt; areas.length; i++) { total += areas[i]; } return total;}geoService.project(projectParams) .then(bufferPoints) .then(addGraphicsToBufferLayer) .then(calculateAreas) .then(sumArea) .catch((error) =&gt; { console.error(&quot;One of the promises in the chain was rejected! Message:&quot;, error); }); 也可以使用async，await关键词，简单来说，它们是基于Promise的语法糖，使异步代码看起来更像是同步代码。具体请查阅文档。 手动加载如果View是用Map实例构造的，那么load方法会自动执行，加载View和关联的Map中引用的所有资源。简单来讲，当实例化的图层并没有被map或view引用时，图层服务的所有资源并不会自动加载，需要手动调用load方法加载它所需的资源来完成初始化。 load状态包括not-loaded，loading，failed，loaded，分别代表尚未加载，加载中，加载失败和加载成功。 下面的状态转换代表了一个可加载资源所经历的阶段。 可以用以下代码验证load状态： 1234567891011121314151617181920require([&quot;esri/Map&quot;, &quot;esri/views/MapView&quot;, &quot;esri/layers/FeatureLayer&quot;], (Map, MapView, FeatureLayer) =&gt; { const map = new Map({ basemap: &quot;osm&quot; }) const view = new MapView({ map, container: &quot;view&quot; }) const layer = new FeatureLayer({ url: &quot;https://sampleserver6.arcgisonline.com/arcgis/rest/services/USA/MapServer/0&quot; }); console.log(layer.loadStatus) console.log(layer.fields) layer.load().then(() =&gt; { console.log(layer.loadStatus) console.log(layer.fields) }, (err) =&gt; { console.log(err) }) }); 这是一个没有与Map或者View关联的FeatureLayer，在实例化之后输出它的加载状态和包含的字段属性，并在手动调用load()之后再次输出加载状态和包含的字段。浏览器输出如下所示： 从结果可验证如上所说。 fromJSON 方法fromJSON方法从ArcGIS产品生成的JSON中创建一个指定类的实例。这种格式的JSON通常由toJSON()方法或通过REST API的查询创建。不能与一般的JSON或GeoJSON混用。 jsonUtils 辅助方法在使用fromJSON()实例化一个对象时，有几个jsonUtils类作为工具类提供。 esri/geometry/support/jsonUtils esri/renderers/support/jsonUtils esri/symbols/support/jsonUtils 当一个JSON对象是来自REST API的几何体、渲染器或符号，但对象类型未知时，这些类可以快速处理这种情况。例如，当一个图层的渲染器来自于REST请求，并且不确定该渲染器是否是UniqueValueRenderer时，调用esri/renderers/support/jsonUtils类来帮助确定该渲染器的类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566require([ &quot;esri/renderers/support/jsonUtils&quot;, &quot;esri/layers/FeatureLayer&quot;], ( rendererJsonUtils, FeatureLayer ) =&gt; { const rendererJSON = { // renderer object obtained via REST request &quot;authoringInfo&quot;:null, &quot;type&quot;:&quot;uniqueValue&quot;, &quot;field1&quot;:&quot;CLASS&quot;, &quot;field2&quot;:null, &quot;field3&quot;:null, &quot;expression&quot;:null, &quot;fieldDelimiter&quot;:null, &quot;defaultSymbol&quot;:{ &quot;color&quot;:[ 235, 235, 235, 255 ], &quot;type&quot;:&quot;esriSLS&quot;, &quot;width&quot;:3, &quot;style&quot;:&quot;esriSLSShortDot&quot; }, &quot;defaultLabel&quot;:&quot;Other major roads&quot;, &quot;uniqueValueInfos&quot;:[ { &quot;value&quot;:&quot;I&quot;, &quot;symbol&quot;:{ &quot;color&quot;:[ 255, 170, 0, 255 ], &quot;type&quot;:&quot;esriSLS&quot;, &quot;width&quot;:10, &quot;style&quot;:&quot;esriSLSSolid&quot; }, &quot;label&quot;:&quot;Interstate&quot; }, { &quot;value&quot;:&quot;U&quot;, &quot;symbol&quot;:{ &quot;color&quot;:[ 223, 115, 255, 255 ], &quot;type&quot;:&quot;esriSLS&quot;, &quot;width&quot;:7, &quot;style&quot;:&quot;esriSLSSolid&quot; }, &quot;label&quot;:&quot;US Highway&quot; } ] }; // Create a renderer object from its JSON representation const flRenderer = rendererJsonUtils.fromJSON(rendererJSON); // Set the renderer on a layer const layer = new FeatureLayer({ renderer: flRenderer });});","link":"/2022/03/30/ArcGIS-API-for-JavaScript-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E/"},{"title":"核心概念之Map和View","text":"Map是用于管理图层和底图引用的容器。View用于显示地图图层并处理用户交互，弹出窗口，小部件和地图位置。通俗来说，可以理解为Map负责地图数据的管理，而View负责处理地图数据的显示及地图与用户之间的交互。 Map介绍地图是由Map类创建的。Map对象总是被传递给一个View对象。有两个View类用于显示地图：MapView类用于展示2D地图，SceneView类用于展示3D地图。 创建Map一般方法创建map的一种方法是建立一个新的Map类的实例，同时指定一个底图和可选的图层集合。 底图与图层类型在后续的章节会详细说明。 123456789const myMap = new Map({ // Create a Map object basemap: &quot;streets-vector&quot;, layers: additionalLayers // Optionally, add additional layers collection});const mapView = new MapView({ // The View for the Map object map: myMap, container: &quot;mapDiv&quot;}); 通过Web Map或Web Scene创建map的第二种方式是加载 web map（用于2D地图）或web scene（用于3D地图）。 Web Map和Web Scene是包含地图或场景设置的JSON结构。这包括对底图、图层、图层样式、弹出窗口、图例、标签等的设置。它们通常是通过ArcGIS Online地图查看器或ArcGIS Online场景查看器创建的。ArcGIS Online或ArcGIS Enterprise会给它们分配一个唯一的ID，并将它们存储为portal items。 示例：https://www.arcgis.com/home/item.html?id=41281c51f9de45edaf1c8ed44bb10e30 通过WebMap创建 1234567891011const webMap = new WebMap({ // Define the web map reference portalItem: { id: &quot;41281c51f9de45edaf1c8ed44bb10e30&quot;, portal: &quot;https://www.arcgis.com&quot; // Default: The ArcGIS Online Portal }});const view = new MapView({ map: webMap, // Load the web map container: &quot;viewDiv&quot;}); 通过WebScene创建 1234567891011const webScene = new WebScene({ // Define the web scene reference portalItem: { id: &quot;579f97b2f3b94d4a8e48a5f140a6639b&quot;, portal: &quot;https://www.arcgis.com&quot; // Default: The ArcGIS Online Portal }});const view = new SceneView({ // Load the web scene map: webScene, container: &quot;viewDiv&quot;}); View介绍有单独的类用于创建map和scene的视图：MapView和SceneView类。MapView显示的是Map对象的2D视图，SceneView显示的是3D视图。 创建View为了使地图可见，view对象需要一个map对象和一个识别div元素或div元素引用的id属性的字符串。 创建MapView 1234const mapView = new MapView({ // Create MapView object map: myMap, container: &quot;mapViewDiv&quot;}); 创建SceneView 1234const sceneView = new SceneView({ // Create SceneView object map: myMap, container: &quot;sceneViewDiv&quot;}); 设置map的可视范围MapView和SceneView的初始位置可以在创建视图时通过设置 center 和 zoom 或者 scale属性来设置。 1234const view = new MapView({ center: [ -112, 38 ], // The center of the map as lon/lat zoom: 13 // Sets the zoom level of detail (LOD) to 13}); 视图的位置在初始化后也可以通过更新属性来更新。 当使用SceneView（3D）时，可以通过定义 camera属性来设置观察者的位置。 1234567891011const view = new SceneView({ camera: { position: [ -122, // lon 38, // lat 50000 // elevation in meters ], heading: 95, // direction the camera is looking tilt: 65 // tilt of the camera relative to the ground }}); 将视图通过动画改变位置MapView的goTo方法也会改变视图的位置，但提供了额外的选项来平稳过渡。这种技术经常被用来从表面上的一个位置 “飞 “到另一个位置，或者放大到搜索结果。goTo方法可以接受一个Geometry, Graphic, or Viewpoint对象。其他选项可以控制动画效果。 1234567view.goTo({ // go to point with a custom animation duration target: { center: [ -114, 39 ] }, { duration: 5000 });}); 效果预览： 与视图交互View还负责处理用户交互和显示弹出窗口。View为用户的交互提供了多个事件处理程序，如鼠标点击、键盘输入、触摸屏互动、摇杆和其他输入设备。 示例： 当用户点击地图时，默认行为是显示图层中已经预先配置好的弹出窗口。这种行为也可以用代码手动实现，即监听点击事件并使用hitTest()方法来寻找用户点击的要素。 1234567891011121314view.popup.autoOpenEnabled = false; // Disable the default popup behaviorview.on(&quot;click&quot;, function(event) { // Listen for the click event view.hitTest(event).then(function (hitTestResults){ // Search for features where the user clicked if(hitTestResults.results) { view.popup.open({ // open a popup to show some of the results location: event.mapPoint, title: &quot;Hit Test Results&quot;, content: hitTestResults.results.length + &quot;Features Found&quot; }); } })}); 添加小部件和 UI 组件view也是一个添加小部件和HTML元素的容器。view.ui提供了一个DefaultUI容器，用来显示视图的默认widget。通过使用view.ui.add方法，也可以将额外的widget和HTML Elements添加到视图中。 演示添加搜索widget： 12345678var searchWidget = new Search({ view: view});// Add the search widget to the top right corner of the viewview.ui.add(searchWidget, { position: &quot;top-right&quot;});","link":"/2022/03/30/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B9%8BMap%E5%92%8CView/"},{"title":"核心概念之图层和数据（上）","text":"图层是可在Map中使用的数据集合。图层数据可以在前端创建，或者由 ArcGIS Online 和 ArcGIS Enterprise 发布，或由外部服务器托管。 要素集合要素（feature） : 要素是对地理位置或实体的记录。每个要素都包含为一种几何类型（点、折线或多边形）定义的空间坐标和存储其他信息的属性字段。 图层通常用来管理和显示大量的要素集合。要素集合又分为结构化和非结构化^1。如果要显示要素集合时，一般的做法是： 如果数据是结构化的，使用FeatureLayer来显示数据 如果是非结构化的，用GraphicsLayer来显示数据 Map作为数据的容器，存放着各种不同类型的图层，图层又是由要素集合组成，每个要素都要包含attributes、geometry、symbol属性才能正常显示，popupTemplate为可选属性，定义了要素弹出窗口的显示内容。 常见图层类型ArcGIS API for JavaScript有许多图层类，可用于访问和显示图层数据。所有的图层类都继承于Layer。使用哪种图层类取决于数据的格式和数据的存储位置。每个图层类还带有不同的方法。 常用图层类型介绍如下： FeatureLayer，存储在ArcGIS Enterprise中的地理数据，主要用于显示、查询、过滤和编辑大量的地理要素。 GraphicsLayer，临时存储在内存中的地理数据，主要用于在地图上以图形或文字的形式显示少数地理要素。 CSVLayer/KMLLayer/GeoJSONLayer，存储在可通过网络访问的外部文件中的地理数据，主要用于将外部文件存储的地理数据显示为一个图层。 TileLayer/VectorTileLayer，数据以切片方案存储，以实现快速渲染，主要用于在地理背景中显示底图和其他切片数据集。 MapImageLayer，存储在ArcGIS Enterprise中并动态生成图片展示相应地理数据。主要用于展示由ArcGIS Server服务动态渲染的图层。 ImageryLayer，存储在ArcGIS Enterprise中的地理相关影像。主要用于展示卫星或其他影像数据。 FeatureLayer介绍FeatureLayer的数据源可以是内存中由应用程序加载的数据，也可以是从ArcGIS Enterprise上托管的REST API服务中请求的数据。在ArcGIS Enterprise中发布服务数据是首选方法，尤其是在访问和显示大量地理数据时。图层在客户端和服务器上都得到了高度优化，可以快速显示，并支持一些其他功能。 服务端构建图层FeatureLayer支持从REST API服务返回的要素集合生成图层。这是访问和显示大型数据集的最有效方式。 12345var layer = new FeatureLayer({ url: &quot;https://services3.arcgis.com/GVgbJbqm8hXASVYi/arcgis/rest/services/Trailheads/FeatureServer/0&quot;});map.layers.add(layer); 客户端构建图层通常情况下，图层数据是从ArcGIS Enterprise上托管的REST API服务加载的，但也可以直接从内存中的要素集合中创建一个FeatureLayer。 示例JSON数据： 12345678910111213141516{ &quot;places&quot;: [ { &quot;id&quot;: 1, &quot;address&quot;: &quot;200 N Spring St, Los Angeles, CA 90012&quot;, &quot;longitude&quot;: -118.24354, &quot;latitude&quot;: 34.05389 }, { &quot;id&quot;: 2, &quot;address&quot;: &quot;419 N Fairfax Ave, Los Angeles, CA 90036&quot;, &quot;longitude&quot;: -118.31966, &quot;latitude&quot;: 34.13375 } ]} 从示例JSON数据中创建一个FeatureLayer需要以下步骤： 将places数组每一项转化为一个具有属性和几何的Graphic对象。Graphic对象主要包含attributes和geometry属性，分别负责设置要素的图形和属性。 123456789101112const graphics = places.map(function (place) { return new Graphic({ attributes: { ObjectId: place.id, address: place.address }, geometry: { longitude: place.longitude, latitude: place.latitude } });}); 创建一个FeatureLayer对象，并指定objectIdField, fields, renderer, and source属性。objectIdField用于标识该要素的唯一地段名，可理解为指定哪个字段为id字段，field属性是一个对象数组，用于指定要素含有哪些字段及值类型，renderer属性用于设置要素的渲染器，source属性指定创建FeatureLayer的图形对象的集合。 1234567891011121314151617181920212223242526272829const featureLayer = new FeatureLayer({ source: graphics, renderer: { type: &quot;simple&quot;, // autocasts as new SimpleRenderer() symbol: { // autocasts as new SimpleMarkerSymbol() type: &quot;simple-marker&quot;, color: &quot;#102A44&quot;, outline: { // autocasts as new SimpleLineSymbol() color: &quot;#598DD8&quot;, width: 2 } } }, objectIdField: &quot;ObjectID&quot;, // This must be defined when creating a layer from `Graphic` objects fields: [ { name: &quot;ObjectID&quot;, alias: &quot;ObjectID&quot;, type: &quot;oid&quot; }, { name: &quot;address&quot;, alias: &quot;address&quot;, type: &quot;string&quot; } ]});map.layers.add(featureLayer); GraphicsLayer介绍Graphics 通常用于向地图临时添加文本、和具有不同类型的图形。创建graphics layer的最简单方法是将 Graphic 对象创建为一个数组，并将这个数组传递给一个新的 GraphicsLayer 对象的 graphics 属性。 可以将graphic理解为单个要素，所以需要attributes、geometry、symbol属性才能正常显示。 12345678910111213141516171819202122232425const pointGraphic = new Graphic({ attributes: { name: &quot;LA City Hall&quot;, address: &quot;200 N Spring St, Los Angeles, CA 90012&quot; }, geometry: { type: &quot;point&quot;, // autocasts as new Point() longitude: -118.24354, latitude: 34.05389 }, symbol: { type: &quot;simple-marker&quot;, // autocasts as new SimpleMarkerSymbol() color: [ 226, 119, 40 ], outline: { // autocasts as SimpleLineSymbol() color: [ 255, 255, 255 ], width: 2 } }});const graphicsLayer = new GraphicsLayer({ graphics: [ pointGraphic ]});map.layers.add(graphicsLayer);","link":"/2022/03/30/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%9B%BE%E5%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8A%EF%BC%89/"},{"title":"核心概念之图层和数据（下）","text":"外部数据源图层介绍外部数据源的数据和文件是由Layer类的不同子类支持的。包括用于处理外部文件（如CSV或GeoJSON文件）或加载外部地图（如GeoQ，高德，Bing Maps）的特定类型的层。 常见的外部数据源图层有以下几种： CSVLayer，数据来源为CSV文件，数据类型为点的矢量图形，支持的特性包括客户端地理处理、弹出窗口、支持2D和3D符号渲染。限制主要是可能根据要素个数，需要下载大量数据、 GeoJSONLayer，数据来源为GeoJSON文件，数据类型为点、折线和多边形的矢量图形，主要用于从 GeoJSON 文件创建图层。限制是每个GeoJSON图层只能接受一个单一的几何体类型。 OGCFeatureLayer，数据类型包括点、线和多边形，支持渲染器、标签和弹出窗口等。 WFSLayer，数据来源为WFS 服务，数据类型支持点、多点、线和多边形，支持渲染器、标签、弹出窗口，但是限制数据必须是GeoJSON格式，只支持2.0.0版本。 WMSLayer，数据来源为WMS 服务，数据类型支持栅格数据导出的单个图像，支持OGC规范。 WMTSLayer，数据来源为WMTS切片服务，数据类型为切片图像，支持OGC规范。 OpenStreetMapLayer，数据来源为OSM切片服务，数据类型为切片图像，用来展示OpenStreetMap的切片地图。 以上每个图层在初始化的时候都需要不同的属性，请参考每个图层类型文档了解更多。 创建CSVLayer的示例： 12345678const earthquakesLayer = new CSVLayer({ url: &quot;https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.csv&quot;, copyright: &quot;USGS Earthquakes&quot;, latitudeField: &quot;latitude&quot;, // Defaults to &quot;latitude&quot; longitudeField: &quot;longitude&quot; // Defaults to &quot;longitude&quot;});map.layers.add(earthquakesLayer) 底图介绍底图为地图提供地理背景。底图通常以切片地图的形式提供，以加快渲染。栅格底图要预先对底图切片。矢量底图以压缩的二进制格式提供数据，并在客户端上进行渲染。ArcGIS自带了一系列底图[^1]。 自定义地图数据也可以通过ArcGIS Enterprise发布成矢量或栅格切片底图。 一个特定的Map对象的底图可以用basemap属性来控制，这个属性可以是一个字符串或一个Basemap对象。 123const Map = new Map({ basemap: &quot;streets-navigation-vector&quot;}) ArcGIS Server服务介绍MapImageLayer用于显示ArcGIS Enterprise发布的Map Service。Map Service通常包含多个子图层和复杂的制图。地图服务将数据渲染成服务器端的图像，并在客户端显示。 12345678910111213const layer = new MapImageLayer({ url: &quot;https://sampleserver6.arcgisonline.com/arcgis/rest/services/USA/MapServer&quot;, sublayers: [ { id: 1, visible: true }, { id: 0, visible: true, definitionExpression: &quot;pop2000 &gt; 100000&quot; } ]}); ImageryLayer用于显示ArcGIS Enterprise发布的 Image Service 的图像或其他栅格数据。 1234const layer = new ImageryLayer({ // URL to the imagery service url: &quot;https://landsat2.arcgis.com/arcgis/rest/services/Landsat8_Views/ImageServer&quot;}); [^1]:一些ArcGIS底图需要API key调用，另一部分则无需配置，直接调用，具体请查阅ArcGIS开发者网站。","link":"/2022/03/30/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%9B%BE%E5%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%8B%EF%BC%89/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","link":"/tags/ArcGIS/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"安装","slug":"安装","link":"/tags/%E5%AE%89%E8%A3%85/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"使用方法","slug":"使用方法","link":"/tags/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"核心概念","slug":"核心概念","link":"/tags/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"},{"name":"图层","slug":"图层","link":"/tags/%E5%9B%BE%E5%B1%82/"}],"categories":[{"name":"ArcGIS API for JavaScript基础教程","slug":"ArcGIS-API-for-JavaScript基础教程","link":"/categories/ArcGIS-API-for-JavaScript%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"}]}